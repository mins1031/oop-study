# 오브젝트 1장 객체_설계
  '"모든 소프트웨어 모듈에는 세가지 목적이 있다. 1. 실행 중에 재대로 동작하는것 2. 변경을 위해, 변경에 용이하게 존재하는것, 3. 읽기 쉽고 이해하기 쉬운 상태여야 한다."  - 로버트 마틴'
  - 대부분의 소프트웨어는 1번은 그럭저럭 만족하게 된다. 그렇다면 2번과 3번은?
  - 해당 프로젝트의 step1과 step2가 있다. 1은 절차지향적으로 구성된 코드이고 2는 캡슐화가 진행된 객체지향적 코드이다.
  - 결국 객체지향적 코드라는건 캡슐화를 진행하며 객체간의 자율성을 높이는 것이다.
  - 그럼 객체의 자율성이라는 건 무엇일까? -> 객체는 객체의 '역할'을 가지고 있고 그에 맞는 데이터(필드)와 인터페이스(메서드)를 가지고 있게 된다. 객체의 역할에 따라 객체의 데이터를 객체 스스로 처리하게 하는 것이 자율성을 높혀주는 것이고 이렇게 자율적으로 객체를 설계하면 객체간 결합도를 낮추고 응집도를 높힐 수 있다.
  - 같은 말 두번하지만 객체를 서로 간에 좋든 실든 의존성이 어느정도 있기 마련이다. 좋은 객체지향 설계의 핵심은 캡슐화를 통해 이 의존성을 적절히 관리함으로서 객체사이의 결합도를 낮추고 응집도를 높혀 코드를 유연하게 만드는 것이다.
  - 다만 결국 설계는 트레이드오프가 일어나기 마련이다. 훌륭한 설계는 균형있는 트레이드오프의 산물이다.
  - 또한 비록 현실에서는 수동적이 존재라고 하더라도(Bag, Ticket등 무생물) 일단 객체지향 설계에 들어오게 되면 모든것이 능동적이고 자율적인 존재로 바뀌게 되고 이러한 원칙을 의읜화라고 표현하는 사람도 있다.
  + 코드는 마음에 드는 부분도 있고 마음에 들지 않는 부분도 있다. 가령 Bag의 필요성이라던지 Seller와 Office의 역할 이라던지...


# 오브젝트 2장 객체지향 프로그래밍
  - 흔히 프로그램 설계시 많은 개발자가 처음하는 행동이 필요한 클래스를 도출하는 것이다. 객체지향 패러다임으로의 전환은 클래스가 아니니 객체에 초점을 맞출떄에만 얻을 수 있다
  - 이를 위해 프로그래밍 하는 동안 두가지를 집중해야한다
    1. 어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민해야한다.
      - 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다. -> 따라서 클래스의 윤곽을 잡기 위해선 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야한다.
      - 객체를 중심에 두는 접근 방법은 설계를 단순하고 깔끔하게 만든다
      - 클래스와 객체의 개념이 조금 모호하긴한데 객체가 조금더 실세계의 내용과 가깝고 이러한 객체들을 프로그래밍 적으로 승화시킨게 클래스라는 느낌이 든다.
    2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야한다.
      - 객체는 홀로 존재하는것이 아니고 다른 객체에게 도움을 주거나 의존하면서 살아가는 협력적 존재이다 (?)
      - 객체를 협력하는 공동체의 일원으로 바라보는 것은 설계를 유연하고 확장가능하게 만든다.
      - 객체지향적으로 생각하고 싶다면 객체를 고립된 존재로 바라보지말고 협력에 참여하는 협력자로 바라보기 바란다. 객체의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현해라.
  - 그리고 1장 예제 에선 금액을 구현시 long타입을 사용했지만 이번엔 Money라는 클래스로 구현했다. 객체를 도출할땐 없던 클래스지만 객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다는 것이다.
  - 따라서 의미를 좀더 명시적이고 분명하게 표현할 수 있고 특정 개념 관련 로직이 많이 생기고 자주 사용되는 경우 객체를 사용해서 해당 개념을 구현해서 사용하면 되는 것이다. -> 유연하게!
  - 다형성이란 동일한 메세지를 수신했을때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다고 한다.
    - 예제 코드상에서 Movie는 DiscountPolicy에게 메시지를 전송하지만 실행 시점에 실제로 실행되는 메서드는 Moive와 협력하는 객체의 실제 클래스가 무엇인지에 따라 달라진다.(퍼센트정책 클래스일지, 일정금액정책 클래스일지)
    - 다시 말해 Movie는 동일한 메시지를 전송하지만 실제로 어떤 클래스의 어떤 메서드가 실행될지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라지고 이것을 다형성이라 부른다.
  - 예제 에선 정책은 추상클래스로, 조건은 인터페이스로 구현했다. 이부분의 차이는 정책은 부모클래스에 데이터가 필요했고 조건은 데이터 없이 메서드만 명시해주면 되는 상황이기에 이렇게 구현되었다.
  - 추상화를 진행했을때는 크게 두가지의 장점이 있다.
    - 첫번쨰로 요구사항의 정책을 높은 수준에서 서술할 수 있다는 점이다. 이부분은 설계 부분에서 설명하고 이해하기에 충분히 도움이 되는 요소인것 같다(아직까진.)
    - 두번쨰로 설계가 좀더 유연해진다는 것이다. 기존 구조를 변경하지않고 새로운기능을 쉽게 추가하거나 변경할 수 있다. 이런 유연함 때문에 정말 자유자제로 추상화와 다형성을 활용하고 싶다..
  - 코드 재사용
    > 상속은 코드를 재사용하기 위해 널리 사용되는 방법이다. 그러나 널리 사용된다고 해서 좋은방법이라는 보장은 없다. 보통 객체지향적으로 구현하려 노력하는 사람들은 대부분 상속보다는 합성이 더 좋은 방법 이라는 이야기를 많이 들었을 것이다.
    - 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용 하는것이다.
      - movie가 DiscountPolicy 코드를 재사용 하는 방식이 바로 합성이다.
      - 그럼 왜 상속보다 합성일까?
    - 상속은 두가지 관점에서 설계에 안좋은 영향을 미친다.
      1) 상속은 캡슐화를 위반한다
        - 부모클래스의 구현이 자식클래스에 그대로 노출되 캡슐화가 약화된다.
        - 캡슐화가 약화되면 부모클래스와 자식클래스가 자연적으로 강하게 결합되기 때문에 부모 클래스를 변경할때 자식클래스도 영향을 받을 확률이 매우 크다.
        - 결과적으로 상속을 과도하게 사용한 코드는 변경하기도 어려워 진다.
      2) 설계를 유연하지 못하게 만든다
        - 상속은 부모클래스와 자식클래스 사이의 관계를 컴파일시점에 결정한다. 따라서 실행 시점에 객체의 종류를 변경하는 것이 불가능 하다.

# 오브젝트 3장 역할, 책임, 협력
  > 객체지향 패러다임의 관점에서 핵심은 역할, 책임. 협력이다. 클래스, 상속, 지연바인딩이 중요하지 않은것은 아니지만 다분히 구현 측면에 지처쳐있기 때문에 객체지향 패러다임의 본질과는 거리가 멀다
  - 객체지향의 본질은 협력하는 객체들의 공동체를 창조하는 것이다.
  - 객체지향 설계의 핵심은 협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정에서 드러난다. 클래스와 상속은 객체들의 책임과 협력이 어느ㅏ정도 자리를 잡은 후에 사용할 수 있는 구현 메터니즘일 뿐이다.
  - 어플리케이션의 기능을 구현하기 위해 어떤 협력이 필요하고 협력을위해 어떤 역할과 책임이 필요한지를 고민하지 않은 채 이른시기에 구현에 초점을 맞추는 것은 변경하기 어렵고 유연하지 못한 코드를 낳는 원인이 된다.
    - 여기서 중요한게 기능을 구현하기전 해당 기능에 어떤 객체가 필요하고 어떤 협력이 필요한지 고민후에 객체를 만들어 그 객체에 대한 데이터와 인터페이스를 할당하는 순서로 진행하라는건데 기억했다 해봐야겠다.
    ## 3-1 협력
      > 객체지향 시스템은 자율적인 객체들의 공동체다. 협력은 객체지향의 세계에서 기능을 구현할 수 있는 유일한 방법이다.
      - 두 객체 사의의 협력은 하나의 객체가 다른 객체에게 도움을 요청할 때 시작된다.
      - 메시지 전송은 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단이다. 객체는 다른 객체의 상세한 내부 구현에 직접 접근할 수 없기에 오직 메세지 전송을 통해서만 자신의 요청을 전달할 수 있다.
      - 2장의 예제에서 Screening이 Movie에게 calculateMovieFee 라는 메서드를 통해 요금에 대한 처리를 위임하는 것은 요금을 계산하는데 필요한 기본 요금과 할인 정책을 가장 잘 알고 있는 객체가 Movie이기 때문이다.
        - 요금을 계산하는 작업을 S가 수행한다면 M의 인스턴스 변수인 fee와 discountPolicy에 직접 접근해야할 것이다. 이경우 S는 M의 내부 구현에 결합된다.
        - 가장 큰 문제점은 M의 자율성이 훼손된다는 것이다. 자율적인 객체란 자신의 상태를 직접, 스스로의 결정에 따라 행동하는 객체다. 하지만 S가 M의 정보를 이용해 요금을 계산 할 경우 정보와 행동이 M와 S이라는 별도의 객체로 나뉜다.
        - 결과적으로 M은 자율적인 존재가 아니라 수동적인 존재로 전락하고 만다.
        - 결국 계속강조하지만 객체는 자율적인 존재로 만들어야 하고, 객체를 자율적인 존재로 만드는 방법은 고도의 캡슐화 작업이라는 것이다.
      - 내가 지금까지 잘못 생각하고 있는 부분이 어떤 기능을 구현하려고 구현로직과 클래스에 대한 내용만 생각했었다.
      - 협력에 대한 내용은 위의 생각을 조금 바꾸어 주었는데 결론을 말하자면 본질에 대한 포커싱과 순서의 차이였다.
      - 객체지향은 객체를 중심에 놓는 프로그래밍 페러다임이다. 여기서 객체란 상태와 행동을 함께 캡술화한 실행단위이다.
      - **그렇다면 객체가 가질수 있는 상태와 행동을 어떤 기준으로 결정해야 할까?**
      - 결론적으로 객체의 행동을 결정하는 것은 **객체가 참여하고 있는 협력이다**.
      - 협력이 바뀌면 객체가 제공해야 하는 행동역시 바뀌어야 한다. 협력은 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공한다
        - M객체는 어떤 행동을 수행할 수 있어야 할까?. 영화라는 단어는 대부분의 사람들은 영화를 상영하는 장면을 상상할 것이고, 자연스럽게 M객체가 play라는 행동을 수행할 것이라고 생각할 것이다(아마?)
        - 그러나 영화 예매 시스템안의 M 에는 영화를 상영하기 위한 어떤 코드도 포함돼 있지 않고 오히려 대부분의 메서드는 요금을 계산하는 행동과 관련된 것들이다.
        - 이것은 M이 영화를 예매하기위한 협력에 참여하고 있고 그안에서 요금을 계산하는 책임을 지고 있기 때문이다
        - M의 행동을 결정하는 것은 '영화 예매'를 위한 '협력'이다. 협력이라는 문맥을 고려하지 않고 M의 행동을 결정하는것은 아무 의미 없다. 협력이 존재하기에 객체가 존재하는것이다.
        - **객체의 행동을 결정하는 것이 협력이라면 객체의 상태를 결정하는 것은 행동이다.**
        - M이 기본요금인 fee와 할인 정책인 discountPolicy라는 인스턴스 변수를 상태의 일부로 포함하는 이유는 '요금계산' 이라는 행동을 수행하는데 이 정보들이 필요하기 때문이다.
    ## 3-2 책임
      > 객체를 설계하기 위해 필요한 문맥인 협력이 갖춰졌다고 하면 다음으로 할 일은 협력에 필요한 행동을 수행할 수 있는 적절한 객체를 찾는 것이다. 이 떄 협력에 참여하기 위해 객체가 수행하는 행동을 '책임'이라고 부른다

      ### 책임이란?
        - 책임이란 객체에 의해 정의되는 응집도 있는 행위의 집합으로 객체가 유지해야 하는 정보와 수행할 수 있는 행동에 대해 개략적으로 서술한 문장이다.
        - 즉, 객체의 책임은 객체가 '무엇을 알고 있는가' 와 '무엇을 할 수 있는가'로 구성된다.
        - S가 reserve 메시지를 수신하고 M를 인스턴스 변수로 포함하는 이유는 협력 안에서 영화를 예매할 책임을 수행해야 하기 때문이다.
        - M가 calculateMovieFee메시지를 수신할 수 있고 fee와 discountpolicy를 속성으로 가지는 이유는 협력안에서 가격을 계산할 책임을 할당 받았기 때문이다.
        - 이처럼 협력 안에서 객체에게 할당한 책임이 외부의 인터페이스와 내부의 속성을 결정한다.
        - 고로 책임은 객체지향 설계의 핵심이다. 객체에게 얼마나 적절한 책임을 할당 하느냐가ㅏ 설계의 전체적인 품질을 결정한다.
      ### 책임 할당
        - 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것이다.
        - 따라서 객체에게 책임을 할당하기 위해선 먼저 협력이라는 문맥을 정의해야 한다.
        - 협력 설계의 출발점은 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 바라보는 것이다.
        - 객체지향 설계는 시스템의 책임을 완료하느느데 필요한 더 작은 책임을 찾아내고 이를 객체들에게 할당하는 반복적인 과정을 통해 모양을 갖춰간다.
        - 이렇게 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을 책임주도 설계라고 부른다.
          1) 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
          2) 시스템 책임을 더 작은 책임으로 분할한다.
          3) 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
          4) 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
          5) 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.
        - 여기서 책임을 할당할때 고려해야 하는 두가지 요소가 있다.
          1) 메세지가 객체를 결정하는것: 객체가 최소한의 인터페이스를 가지게 되어 필요한 크기의 퍼블릭 인터페이스를 가질수 있게 된다, 추상적 인터페이스를 가지게 되어 무엇을 하는지는 표현하지만 어떻게 하는지를 노출시키지 않게 된다.
          2) 행동이 상태를 결정한다: 상태를 먼저 결정하고 행동을 정의하게 되면 캡슐화를 저해할 확률이 높아진다. 따라서 구현에 대한 결정을 뒤로 미루며 객체의 행위를 고려하기 위해 위애서 보았던것 처럼 항상 협력과 책임에 먼저 신경써야한다.
      ### 항상 중요한것은 객체의 상태가 아니라 행동이다. 행동이 중요하다. 객체가 가질수 있는 상태는 행동을 결정하고 나서야 비로소 결정할 수 있는 것이다.
    ## 3-3 역할
      ### 역할과 협력
      > 객체는 협력이라는 주어진 문맥안에서 특정한 목적을 갖게 된다. 객체의 목적은 협력 안에서 객체가 맡게 되는 책임의 집합으로 표시된다.
      - 이처럼 객체가 특정한 협력 안에서 수행하는 책임의 집합을 '역할'이라고 부른다.
      - 3-3의 내용은 길고 장황하게 서술되어있지만 간단히 말해서 역할은 객체가 참여할 수 있는 일종의 슬롯이다
      - 한 협력안에서 메세지를 어떤객체가 전달받을지에 대해 생각해여 나온 부분이 역할이라는 배역이고 알맞는 객체라는 배우를 이 배역에 할당해주는 내용이다
      - 다만 하나의 역할을 수행하는게 하나의 객체만 있다면 둘을 분리해서 생각하는 개념이 애매하지만(역할=객체 라고 봐도 거의 무방) 한 역할을 여러 객체가 수행할 수 있다면 객체와 역할의 의미를 따로 두고 봐야한다
      - 만약 한 역할을 여러 객체가 할 수 있는경우 추상화와 다형성을 통해 자바 인터페이스나 추상클래스로 구현해 적용하는것이 바람직하다
      - 추가적으로 객체지향 설계 초반에는 적절한 책임과 협력의 큰그림을 탐색하는 것이 훨씬, 가장 중요한 목표이고 역할과 객체를 명확하게 구분하는 것은(인터페이스,추상클래스 적용) 그렇게 초반엔 중요하지 않다는 것이다.

    - 협력이라는 문맥 안에서 역할은 특정한 협력에 참여해서 책임을 수행하는 객체의 일부이다.
    - 일반적으로 역할은 객체가 협력에 참여하는 잠시동안에만 존재하는 일시적인 개념이다.
    - 객체는 다양한 역할으르 가질 수 있다.
    - 객체는 협력에 참여할 때 협력 안에서 하나의 역할로 보여진다. 객체가 다른 협력에 참여할 때는 다른 역할로 보여진다.
    - 하나의 기능에 대해 협력을 그려보고 적절한 책임 구조를 먼저 구상한다음 적절한 메서드를 만들고 거기에 필요한 필드를 객체에 추가해준다. 이후 역할을 명확히 할 필요성이 생긴다면 추상화를 통해 구현해준디. 라고 전체 내용을 이해해본다.

# 오브젝트 4장 설계품질과 트레이드오프
  > 설계는 변경을 위해 존재하고 변경에는 어떤식으로든 비용이 발생한다. 훌륭한 설계란 합리적인 비용안에서 변경을 수용할 수 있는 구조를 만드는 것이다.
  - 적절한 비용 안에서 쉽게 변경할 수 있는 설계는 응집도가 높고 서로 느슨하게 결합돼 있는 요소로 구성된다.
  - 결합도와 응집도를 합리적인 수준으로 유지할 수 있는 중요한 원칙은 앞에서도 보았듯이 객체의 '상태'가 아니라 '행동'에 초점을 맞추는 것이다.
  ## 4-1 데이터 중심의 영화 예매 시스템
    - 객체지향 설계에서는 두가지 방법을 이용해 시스템을 객체로 분할 할 수 있다.
      1) 상태를 분할의 중심축으로 삼는 방법
      2) 책임을 분할의 중심축으로 삼는 방법
    - 물론 훌륭한 객체지향 설계는 상태(데이터)가 아니라 책임에 초점을 맞춰 설계해야 하지만 둘에 대한 예시를 보면서 파악하면 훨씬 잘 와닿을수 있기에 데이터 기준의 코드를 구현해 보겠다.
    - 데이터 중심의 설계란 객체 내부에 저장되는 데이터를 기반으로 시스템을 분할 하는 방법이다.
