# 오브젝트 1장 객체_설계
  '"모든 소프트웨어 모듈에는 세가지 목적이 있다. 1. 실행 중에 재대로 동작하는것 2. 변경을 위해, 변경에 용이하게 존재하는것, 3. 읽기 쉽고 이해하기 쉬운 상태여야 한다."  - 로버트 마틴'
  - 대부분의 소프트웨어는 1번은 그럭저럭 만족하게 된다. 그렇다면 2번과 3번은?
  - 해당 프로젝트의 step1과 step2가 있다. 1은 절차지향적으로 구성된 코드이고 2는 캡슐화가 진행된 객체지향적 코드이다.
  - 결국 객체지향적 코드라는건 캡슐화를 진행하며 객체간의 자율성을 높이는 것이다.
  - 그럼 객체의 자율성이라는 건 무엇일까? -> 객체는 객체의 '역할'을 가지고 있고 그에 맞는 데이터(필드)와 인터페이스(메서드)를 가지고 있게 된다. 객체의 역할에 따라 객체의 데이터를 객체 스스로 처리하게 하는 것이 자율성을 높혀주는 것이고 이렇게 자율적으로 객체를 설계하면 객체간 결합도를 낮추고 응집도를 높힐 수 있다.
  - 같은 말 두번하지만 객체를 서로 간에 좋든 실든 의존성이 어느정도 있기 마련이다. 좋은 객체지향 설계의 핵심은 캡슐화를 통해 이 의존성을 적절히 관리함으로서 객체사이의 결합도를 낮추고 응집도를 높혀 코드를 유연하게 만드는 것이다.
  - 다만 결국 설계는 트레이드오프가 일어나기 마련이다. 훌륭한 설계는 균형있는 트레이드오프의 산물이다.
  - 또한 비록 현실에서는 수동적이 존재라고 하더라도(Bag, Ticket등 무생물) 일단 객체지향 설계에 들어오게 되면 모든것이 능동적이고 자율적인 존재로 바뀌게 되고 이러한 원칙을 의읜화라고 표현하는 사람도 있다.
  + 코드는 마음에 드는 부분도 있고 마음에 들지 않는 부분도 있다. 가령 Bag의 필요성이라던지 Seller와 Office의 역할 이라던지...


# 오브젝트 2장 객체지향 프로그래밍
  - 흔히 프로그램 설계시 많은 개발자가 처음하는 행동이 필요한 클래스를 도출하는 것이다. 객체지향 패러다임으로의 전환은 클래스가 아니니 객체에 초점을 맞출떄에만 얻을 수 있다
  - 이를 위해 프로그래밍 하는 동안 두가지를 집중해야한다
    1. 어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민해야한다.
      - 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다. -> 따라서 클래스의 윤곽을 잡기 위해선 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야한다.
      - 객체를 중심에 두는 접근 방법은 설계를 단순하고 깔끔하게 만든다
      - 클래스와 객체의 개념이 조금 모호하긴한데 객체가 조금더 실세계의 내용과 가깝고 이러한 객체들을 프로그래밍 적으로 승화시킨게 클래스라는 느낌이 든다.
    2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야한다.
      - 객체는 홀로 존재하는것이 아니고 다른 객체에게 도움을 주거나 의존하면서 살아가는 협력적 존재이다 (?)
      - 객체를 협력하는 공동체의 일원으로 바라보는 것은 설계를 유연하고 확장가능하게 만든다.
      - 객체지향적으로 생각하고 싶다면 객체를 고립된 존재로 바라보지말고 협력에 참여하는 협력자로 바라보기 바란다. 객체의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현해라.
  - 그리고 1장 예제 에선 금액을 구현시 long타입을 사용했지만 이번엔 Money라는 클래스로 구현했다. 객체를 도출할땐 없던 클래스지만 객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다는 것이다.
  - 따라서 의미를 좀더 명시적이고 분명하게 표현할 수 있고 특정 개념 관련 로직이 많이 생기고 자주 사용되는 경우 객체를 사용해서 해당 개념을 구현해서 사용하면 되는 것이다. -> 유연하게!
  - 다형성이란 동일한 메세지를 수신했을때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다고 한다.
    - 예제 코드상에서 Movie는 DiscountPolicy에게 메시지를 전송하지만 실행 시점에 실제로 실행되는 메서드는 Moive와 협력하는 객체의 실제 클래스가 무엇인지에 따라 달라진다.(퍼센트정책 클래스일지, 일정금액정책 클래스일지)
    - 다시 말해 Movie는 동일한 메시지를 전송하지만 실제로 어떤 클래스의 어떤 메서드가 실행될지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라지고 이것을 다형성이라 부른다.
  - 예제 에선 정책은 추상클래스로, 조건은 인터페이스로 구현했다. 이부분의 차이는 정책은 부모클래스에 데이터가 필요했고 조건은 데이터 없이 메서드만 명시해주면 되는 상황이기에 이렇게 구현되었다.
  - 추상화를 진행했을때는 크게 두가지의 장점이 있다.
    - 첫번쨰로 요구사항의 정책을 높은 수준에서 서술할 수 있다는 점이다. 이부분은 설계 부분에서 설명하고 이해하기에 충분히 도움이 되는 요소인것 같다(아직까진.)
    - 두번쨰로 설계가 좀더 유연해진다는 것이다. 기존 구조를 변경하지않고 새로운기능을 쉽게 추가하거나 변경할 수 있다. 이런 유연함 때문에 정말 자유자제로 추상화와 다형성을 활용하고 싶다..
  - 코드 재사용
    > 상속은 코드를 재사용하기 위해 널리 사용되는 방법이다. 그러나 널리 사용된다고 해서 좋은방법이라는 보장은 없다. 보통 객체지향적으로 구현하려 노력하는 사람들은 대부분 상속보다는 합성이 더 좋은 방법 이라는 이야기를 많이 들었을 것이다.
    - 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용 하는것이다.
      - movie가 DiscountPolicy 코드를 재사용 하는 방식이 바로 합성이다.
      - 그럼 왜 상속보다 합성일까?
    - 상속은 두가지 관점에서 설계에 안좋은 영향을 미친다.
      1) 상속은 캡슐화를 위반한다
        - 부모클래스의 구현이 자식클래스에 그대로 노출되 캡슐화가 약화된다.
        - 캡슐화가 약화되면 부모클래스와 자식클래스가 자연적으로 강하게 결합되기 때문에 부모 클래스를 변경할때 자식클래스도 영향을 받을 확률이 매우 크다.
        - 결과적으로 상속을 과도하게 사용한 코드는 변경하기도 어려워 진다.
      2) 설계를 유연하지 못하게 만든다
        - 상속은 부모클래스와 자식클래스 사이의 관계를 컴파일시점에 결정한다. 따라서 실행 시점에 객체의 종류를 변경하는 것이 불가능 하다.
      