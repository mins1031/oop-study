# 오브젝트 1장 객체_설계
  '"모든 소프트웨어 모듈에는 세가지 목적이 있다. 1. 실행 중에 재대로 동작하는것 2. 변경을 위해, 변경에 용이하게 존재하는것, 3. 읽기 쉽고 이해하기 쉬운 상태여야 한다."  - 로버트 마틴'
  - 대부분의 소프트웨어는 1번은 그럭저럭 만족하게 된다. 그렇다면 2번과 3번은?
  - 해당 프로젝트의 step1과 step2가 있다. 1은 절차지향적으로 구성된 코드이고 2는 캡슐화가 진행된 객체지향적 코드이다.
  - 결국 객체지향적 코드라는건 캡슐화를 진행하며 객체간의 자율성을 높이는 것이다.
  - 그럼 객체의 자율성이라는 건 무엇일까? -> 객체는 객체의 '역할'을 가지고 있고 그에 맞는 데이터(필드)와 인터페이스(메서드)를 가지고 있게 된다. 객체의 역할에 따라 객체의 데이터를 객체 스스로 처리하게 하는 것이 자율성을 높혀주는 것이고 이렇게 자율적으로 객체를 설계하면 객체간 결합도를 낮추고 응집도를 높힐 수 있다.
  - 같은 말 두번하지만 객체를 서로 간에 좋든 실든 의존성이 어느정도 있기 마련이다. 좋은 객체지향 설계의 핵심은 캡슐화를 통해 이 의존성을 적절히 관리함으로서 객체사이의 결합도를 낮추고 응집도를 높혀 코드를 유연하게 만드는 것이다.
  - 다만 결국 설계는 트레이드오프가 일어나기 마련이다. 훌륭한 설계는 균형있는 트레이드오프의 산물이다.
  - 또한 비록 현실에서는 수동적이 존재라고 하더라도(Bag, Ticket등 무생물) 일단 객체지향 설계에 들어오게 되면 모든것이 능동적이고 자율적인 존재로 바뀌게 되고 이러한 원칙을 의읜화라고 표현하는 사람도 있다.
  + 코드는 마음에 드는 부분도 있고 마음에 들지 않는 부분도 있다. 가령 Bag의 필요성이라던지 Seller와 Office의 역할 이라던지...


# 오브젝트 2장 객체지향 프로그래밍
  - 흔히 프로그램 설계시 많은 개발자가 처음하는 행동이 필요한 클래스를 도출하는 것이다. 객체지향 패러다임으로의 전환은 클래스가 아니니 객체에 초점을 맞출떄에만 얻을 수 있다
  - 이를 위해 프로그래밍 하는 동안 두가지를 집중해야한다
    1. 어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민해야한다.
      - 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다. -> 따라서 클래스의 윤곽을 잡기 위해선 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야한다.
      - 객체를 중심에 두는 접근 방법은 설계를 단순하고 깔끔하게 만든다
      - 클래스와 객체의 개념이 조금 모호하긴한데 객체가 조금더 실세계의 내용과 가깝고 이러한 객체들을 프로그래밍 적으로 승화시킨게 클래스라는 느낌이 든다.
    2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야한다.
      - 객체는 홀로 존재하는것이 아니고 다른 객체에게 도움을 주거나 의존하면서 살아가는 협력적 존재이다 (?)
      - 객체를 협력하는 공동체의 일원으로 바라보는 것은 설계를 유연하고 확장가능하게 만든다.
      - 객체지향적으로 생각하고 싶다면 객체를 고립된 존재로 바라보지말고 협력에 참여하는 협력자로 바라보기 바란다. 객체의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현해라.
  - 그리고 1장 예제 에선 금액을 구현시 long타입을 사용했지만 이번엔 Money라는 클래스로 구현했다. 객체를 도출할땐 없던 클래스지만 객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다는 것이다.
  - 따라서 의미를 좀더 명시적이고 분명하게 표현할 수 있고 특정 개념 관련 로직이 많이 생기고 자주 사용되는 경우 객체를 사용해서 해당 개념을 구현해서 사용하면 되는 것이다. -> 유연하게!
  - 다형성이란 동일한 메세지를 수신했을때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다고 한다.
    - 예제 코드상에서 Movie는 DiscountPolicy에게 메시지를 전송하지만 실행 시점에 실제로 실행되는 메서드는 Moive와 협력하는 객체의 실제 클래스가 무엇인지에 따라 달라진다.(퍼센트정책 클래스일지, 일정금액정책 클래스일지)
    - 다시 말해 Movie는 동일한 메시지를 전송하지만 실제로 어떤 클래스의 어떤 메서드가 실행될지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라지고 이것을 다형성이라 부른다.
  - 예제 에선 정책은 추상클래스로, 조건은 인터페이스로 구현했다. 이부분의 차이는 정책은 부모클래스에 데이터가 필요했고 조건은 데이터 없이 메서드만 명시해주면 되는 상황이기에 이렇게 구현되었다.
  - 추상화를 진행했을때는 크게 두가지의 장점이 있다.
    - 첫번쨰로 요구사항의 정책을 높은 수준에서 서술할 수 있다는 점이다. 이부분은 설계 부분에서 설명하고 이해하기에 충분히 도움이 되는 요소인것 같다(아직까진.)
    - 두번쨰로 설계가 좀더 유연해진다는 것이다. 기존 구조를 변경하지않고 새로운기능을 쉽게 추가하거나 변경할 수 있다. 이런 유연함 때문에 정말 자유자제로 추상화와 다형성을 활용하고 싶다..
  - 코드 재사용
    > 상속은 코드를 재사용하기 위해 널리 사용되는 방법이다. 그러나 널리 사용된다고 해서 좋은방법이라는 보장은 없다. 보통 객체지향적으로 구현하려 노력하는 사람들은 대부분 상속보다는 합성이 더 좋은 방법 이라는 이야기를 많이 들었을 것이다.
    - 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용 하는것이다.
      - movie가 DiscountPolicy 코드를 재사용 하는 방식이 바로 합성이다.
      - 그럼 왜 상속보다 합성일까?
    - 상속은 두가지 관점에서 설계에 안좋은 영향을 미친다.
      1) 상속은 캡슐화를 위반한다
        - 부모클래스의 구현이 자식클래스에 그대로 노출되 캡슐화가 약화된다.
        - 캡슐화가 약화되면 부모클래스와 자식클래스가 자연적으로 강하게 결합되기 때문에 부모 클래스를 변경할때 자식클래스도 영향을 받을 확률이 매우 크다.
        - 결과적으로 상속을 과도하게 사용한 코드는 변경하기도 어려워 진다.
      2) 설계를 유연하지 못하게 만든다
        - 상속은 부모클래스와 자식클래스 사이의 관계를 컴파일시점에 결정한다. 따라서 실행 시점에 객체의 종류를 변경하는 것이 불가능 하다.

# 오브젝트 3장 역할, 책임, 협력
  > 객체지향 패러다임의 관점에서 핵심은 역할, 책임. 협력이다. 클래스, 상속, 지연바인딩이 중요하지 않은것은 아니지만 다분히 구현 측면에 지처쳐있기 때문에 객체지향 패러다임의 본질과는 거리가 멀다
  - 객체지향의 본질은 협력하는 객체들의 공동체를 창조하는 것이다.
  - 객체지향 설계의 핵심은 협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정에서 드러난다. 클래스와 상속은 객체들의 책임과 협력이 어느ㅏ정도 자리를 잡은 후에 사용할 수 있는 구현 메터니즘일 뿐이다.
  - 어플리케이션의 기능을 구현하기 위해 어떤 협력이 필요하고 협력을위해 어떤 역할과 책임이 필요한지를 고민하지 않은 채 이른시기에 구현에 초점을 맞추는 것은 변경하기 어렵고 유연하지 못한 코드를 낳는 원인이 된다.
    - 여기서 중요한게 기능을 구현하기전 해당 기능에 어떤 객체가 필요하고 어떤 협력이 필요한지 고민후에 객체를 만들어 그 객체에 대한 데이터와 인터페이스를 할당하는 순서로 진행하라는건데 기억했다 해봐야겠다.
    ## 3-1 협력
      > 객체지향 시스템은 자율적인 객체들의 공동체다. 협력은 객체지향의 세계에서 기능을 구현할 수 있는 유일한 방법이다.
      - 두 객체 사의의 협력은 하나의 객체가 다른 객체에게 도움을 요청할 때 시작된다.
      - 메시지 전송은 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단이다. 객체는 다른 객체의 상세한 내부 구현에 직접 접근할 수 없기에 오직 메세지 전송을 통해서만 자신의 요청을 전달할 수 있다.
      - 2장의 예제에서 Screening이 Movie에게 calculateMovieFee 라는 메서드를 통해 요금에 대한 처리를 위임하는 것은 요금을 계산하는데 필요한 기본 요금과 할인 정책을 가장 잘 알고 있는 객체가 Movie이기 때문이다.
        - 요금을 계산하는 작업을 S가 수행한다면 M의 인스턴스 변수인 fee와 discountPolicy에 직접 접근해야할 것이다. 이경우 S는 M의 내부 구현에 결합된다.
        - 가장 큰 문제점은 M의 자율성이 훼손된다는 것이다. 자율적인 객체란 자신의 상태를 직접, 스스로의 결정에 따라 행동하는 객체다. 하지만 S가 M의 정보를 이용해 요금을 계산 할 경우 정보와 행동이 M와 S이라는 별도의 객체로 나뉜다.
        - 결과적으로 M은 자율적인 존재가 아니라 수동적인 존재로 전락하고 만다.
        - 결국 계속강조하지만 객체는 자율적인 존재로 만들어야 하고, 객체를 자율적인 존재로 만드는 방법은 고도의 캡슐화 작업이라는 것이다.
      - 내가 지금까지 잘못 생각하고 있는 부분이 어떤 기능을 구현하려고 구현로직과 클래스에 대한 내용만 생각했었다.
      - 협력에 대한 내용은 위의 생각을 조금 바꾸어 주었는데 결론을 말하자면 본질에 대한 포커싱과 순서의 차이였다.
      - 객체지향은 객체를 중심에 놓는 프로그래밍 페러다임이다. 여기서 객체란 상태와 행동을 함께 캡술화한 실행단위이다.
      - **그렇다면 객체가 가질수 있는 상태와 행동을 어떤 기준으로 결정해야 할까?**
      - 결론적으로 객체의 행동을 결정하는 것은 **객체가 참여하고 있는 협력이다**.
      - 협력이 바뀌면 객체가 제공해야 하는 행동역시 바뀌어야 한다. 협력은 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공한다
        - M객체는 어떤 행동을 수행할 수 있어야 할까?. 영화라는 단어는 대부분의 사람들은 영화를 상영하는 장면을 상상할 것이고, 자연스럽게 M객체가 play라는 행동을 수행할 것이라고 생각할 것이다(아마?)
        - 그러나 영화 예매 시스템안의 M 에는 영화를 상영하기 위한 어떤 코드도 포함돼 있지 않고 오히려 대부분의 메서드는 요금을 계산하는 행동과 관련된 것들이다.
        - 이것은 M이 영화를 예매하기위한 협력에 참여하고 있고 그안에서 요금을 계산하는 책임을 지고 있기 때문이다
        - M의 행동을 결정하는 것은 '영화 예매'를 위한 '협력'이다. 협력이라는 문맥을 고려하지 않고 M의 행동을 결정하는것은 아무 의미 없다. 협력이 존재하기에 객체가 존재하는것이다.
        - **객체의 행동을 결정하는 것이 협력이라면 객체의 상태를 결정하는 것은 행동이다.**
        - M이 기본요금인 fee와 할인 정책인 discountPolicy라는 인스턴스 변수를 상태의 일부로 포함하는 이유는 '요금계산' 이라는 행동을 수행하는데 이 정보들이 필요하기 때문이다.
        
    ## 3-2 책임
      > 객체를 설계하기 위해 필요한 문맥인 협력이 갖춰졌다고 하면 다음으로 할 일은 협력에 필요한 행동을 수행할 수 있는 적절한 객체를 찾는 것이다. 이 떄 협력에 참여하기 위해 객체가 수행하는 행동을 '책임'이라고 부른다
      ### 책임이란?
        - 책임이란 객체에 의해 정의되는 응집도 있는 행위의 집합으로 객체가 유지해야 하는 정보와 수행할 수 있는 행동에 대해 개략적으로 서술한 문장이다.
        - 즉, 객체의 책임은 객체가 '무엇을 알고 있는가' 와 '무엇을 할 수 있는가'로 구성된다.
        - S가 reserve 메시지를 수신하고 M를 인스턴스 변수로 포함하는 이유는 협력 안에서 영화를 예매할 책임을 수행해야 하기 때문이다.
        - M가 calculateMovieFee메시지를 수신할 수 있고 fee와 discountpolicy를 속성으로 가지는 이유는 협력안에서 가격을 계산할 책임을 할당 받았기 때문이다.
        - 이처럼 협력 안에서 객체에게 할당한 책임이 외부의 인터페이스와 내부의 속성을 결정한다.
        - 고로 책임은 객체지향 설계의 핵심이다. 객체에게 얼마나 적절한 책임을 할당 하느냐가ㅏ 설계의 전체적인 품질을 결정한다.
       
      ### 책임 할당
        - 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것이다.
        - 따라서 객체에게 책임을 할당하기 위해선 먼저 협력이라는 문맥을 정의해야 한다.
        - 협력 설계의 출발점은 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 바라보는 것이다.
        - 객체지향 설계는 시스템의 책임을 완료하느느데 필요한 더 작은 책임을 찾아내고 이를 객체들에게 할당하는 반복적인 과정을 통해 모양을 갖춰간다.
        - 이렇게 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을 책임주도 설계라고 부른다.
          1) 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
          2) 시스템 책임을 더 작은 책임으로 분할한다.
          3) 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
          4) 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
          5) 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.
        - 여기서 책임을 할당할때 고려해야 하는 두가지 요소가 있다.
          1) 메세지가 객체를 결정하는것: 객체가 최소한의 인터페이스를 가지게 되어 필요한 크기의 퍼블릭 인터페이스를 가질수 있게 된다, 추상적 인터페이스를 가지게 되어 무엇을 하는지는 표현하지만 어떻게 하는지를 노출시키지 않게 된다.
          2) 행동이 상태를 결정한다: 상태를 먼저 결정하고 행동을 정의하게 되면 캡슐화를 저해할 확률이 높아진다. 따라서 구현에 대한 결정을 뒤로 미루며 객체의 행위를 고려하기 위해 위애서 보았던것 처럼 항상 협력과 책임에 먼저 신경써야한다.
         
      ### 항상 중요한것은 객체의 상태가 아니라 행동이다. 행동이 중요하다. 객체가 가질수 있는 상태는 행동을 결정하고 나서야 비로소 결정할 수 있는 것이다.
      
    ## 3-3 역할
      ### 역할과 협력
      > 객체는 협력이라는 주어진 문맥안에서 특정한 목적을 갖게 된다. 객체의 목적은 협력 안에서 객체가 맡게 되는 책임의 집합으로 표시된다.
      - 이처럼 객체가 특정한 협력 안에서 수행하는 책임의 집합을 '역할'이라고 부른다.
      - 3-3의 내용은 길고 장황하게 서술되어있지만 간단히 말해서 역할은 객체가 참여할 수 있는 일종의 슬롯이다
      - 한 협력안에서 메세지를 어떤객체가 전달받을지에 대해 생각해여 나온 부분이 역할이라는 배역이고 알맞는 객체라는 배우를 이 배역에 할당해주는 내용이다
      - 다만 하나의 역할을 수행하는게 하나의 객체만 있다면 둘을 분리해서 생각하는 개념이 애매하지만(역할=객체 라고 봐도 거의 무방) 한 역할을 여러 객체가 수행할 수 있다면 객체와 역할의 의미를 따로 두고 봐야한다
      - 만약 한 역할을 여러 객체가 할 수 있는경우 추상화와 다형성을 통해 자바 인터페이스나 추상클래스로 구현해 적용하는것이 바람직하다
      - 추가적으로 객체지향 설계 초반에는 적절한 책임과 협력의 큰그림을 탐색하는 것이 훨씬, 가장 중요한 목표이고 역할과 객체를 명확하게 구분하는 것은(인터페이스,추상클래스 적용) 그렇게 초반엔 중요하지 않다는 것이다.

    - 협력이라는 문맥 안에서 역할은 특정한 협력에 참여해서 책임을 수행하는 객체의 일부이다.
    - 일반적으로 역할은 객체가 협력에 참여하는 잠시동안에만 존재하는 일시적인 개념이다.
    - 객체는 다양한 역할으르 가질 수 있다.
    - 객체는 협력에 참여할 때 협력 안에서 하나의 역할로 보여진다. 객체가 다른 협력에 참여할 때는 다른 역할로 보여진다.
    - 하나의 기능에 대해 협력을 그려보고 적절한 책임 구조를 먼저 구상한다음 적절한 메서드를 만들고 거기에 필요한 필드를 객체에 추가해준다. 이후 역할을 명확히 할 필요성이 생긴다면 추상화를 통해 구현해준디. 라고 전체 내용을 이해해본다.

# 오브젝트 4장 설계품질과 트레이드오프
  > 설계는 변경을 위해 존재하고 변경에는 어떤식으로든 비용이 발생한다. 훌륭한 설계란 합리적인 비용안에서 변경을 수용할 수 있는 구조를 만드는 것이다.
  - 적절한 비용 안에서 쉽게 변경할 수 있는 설계는 응집도가 높고 서로 느슨하게 결합돼 있는 요소로 구성된다.
  - 결합도와 응집도를 합리적인 수준으로 유지할 수 있는 중요한 원칙은 앞에서도 보았듯이 객체의 '상태'가 아니라 '행동'에 초점을 맞추는 것이다.
  
  ## 4-1 데이터 중심의 영화 예매 시스템
    - 객체지향 설계에서는 두가지 방법을 이용해 시스템을 객체로 분할 할 수 있다.
      1) 상태를 분할의 중심축으로 삼는 방법
      2) 책임을 분할의 중심축으로 삼는 방법
    - 물론 훌륭한 객체지향 설계는 상태(데이터)가 아니라 책임에 초점을 맞춰 설계해야 하지만 둘에 대한 예시를 보면서 파악하면 훨씬 잘 와닿을수 있기에 데이터 기준의 코드를 구현해 보겠다.
    - 데이터 중심의 설계란 객체 내부에 저장되는 데이터를 기반으로 시스템을 분할 하는 방법이다.
    
  ## 4-2 설계 트레이드 오프
    > 데이터중심 설계와 책임중심 설계의 장단점을 비교하기 위해 캡슐화, 응집도, 결합도 를 사용한다. 그전에 3개가 무엇인지에 대해 파악 해야 한다.
    
    ### 캡슐화
      - 지긋지긋하게 나오지만 그만큼 중요한게 캡슐화인것 같다.
      - 캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 있기 때문이다.
      - 즉 캡슐화란 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법이다. 변경될수 있는 어떤것이라도 캡슐화 해야한다
    ### 응집도와 결합도
      - 응집도: 응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다. 객체지향의 관점에서 응집도는 개체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지를 나타낸다.
      - 결합도: 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타낸다. 객체지향의 관점에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있느지를 나타낸다
      - 일반적으로 좋은 설계란 높은 응집도와 낮은 결합도를 가진 모듈로 구성된 설계를 의미한다.
      - 다시 말해 어플리케이션을 구성하는 각 요소의 응집도가 높고 서로 느슨하게 결합돼 있다면 그 어플리케이션은 좋은 설계를 가졌다고 볼수 있따.
      - 높은 응집도와 낮은 결합도를 가진 설계를 추구해야 하는 이유는 설계를 변경하기 쉽게 만들기 때문이다.
      - 변경의 관점에서 응집도란 '변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도'이다.
      - 변경의 관점에서 결합도는 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도로 측정할 수 있다.
    - 마지막으로 캡슐화의 정도가 응집도와 결합도에 영향을 미친다. 고로 응집도와 결합도를 고려하기 전에 캡슐화를 향상시키기 위해 노력해야 한다.
  ## 4-3 데이터 중심의 영화 예매 시스템의 문제점
    ### 캡슐화 위반
    ```
    public class Movie {
      private Money fee;

      public Money getFee() {
        return fee;
      }

      public void setFee(Money fee) {
        this.fee = fee;
      }
    }
    ```
      - 위의 코드는 얼핏 보면 캡슐화가 지켜진거 같지만 접근자와 수정자 메서드는 객체 내부의 상태에 대한 어떤 정보도 캡슐화하지 못한다.
      - 접근자와 수정자는 객체 내의 fee라는 데이터가 존재한다는 사실을 퍼블릭 인터페이스에 노골적으로 드러낸다
      - Movie가 캡슐화의 원칙을 어기게된 근본적 원인은 객체가 수행할 책임이 아니라 내부에 저장할 데이터에 초점을 맞췄기 때문이다.

    ### 높은 결합도
      - 예제의 ReservatuonAgency의 reserve 메서드는 Reservation부터 DiscountCondition에 이르기 까지 수많은 객체들에 의존하고 있는 형태를 띄고 있다.
      - 결국 ReservatuonAgency는 모든 의존성이 모이는 결합도의 집결지가 되버렸다.
      - 시스템안의 어떤 변경도 ReservatuonAgency의 변경을 유발한다.
      - 이렇게 의존성이 여러군데 산재해 있는= 캡슐화가 잘 지켜지지 않은 코드는 작은 변경하나로도 시스템 전체가 요동칠 수 있다.

    ### 낮은 응집도
      - 서로 다른 이유로 변경되는 코드가 하나의 모듈안에 공존할 때 모듈의 응집도가 낮다고 말한다.
      - 낮은 응집도는 두가지 측면에서 설계에 문제를 일으킨다.
        1) 변경의 이유가 서로 다른 코드들을 하나의 모듈안에 뭉쳐놓았기 때문에 변경과 아무상관없는 코드들이 영향을 받게 된다. 어떤 코드를 수정한 후에 아무 상관없는 코드에 문제가 생기는 경우는 모듈의 응집도가 낮을때 발생하는 대표적인 증상이다.
        2) 하나의 요구사항 변경을 위해 동시에 여러 모듈을 수정해야 한다. 응집도가 낮을 경우 다른 모듈에 위치해야할 책임의 일부가 엉뚱한 곳에 위치하게 되기 때문이다.
        
  ## 4-4 자율적인 객체를 향해
  
    ### 캡슐화를 지켜라
      - 캡슐화는 설계의 제1원칙이다. 데이터 중심의 설계가 낮은 응집도와 높은 결합도라는 문제를 앓는 원인은 캡슐화의 원칙을 위반했기 때문이다.
      - 객체는 자신이 어떤데이터를 가지고 있는지를 내부에 공개해서는 안되며 스스로의 상태를 책임져야 하고 외부에서는 메서드를 통해서만 상태에 접근할 수 있어야 한다.
      - 이제 기존 코드를 조금 캡슐화 해본다. - ch04 refactor 패키지
      
  ## 4-5 아직 부족하다.
    - 분명 regucy 로직보다야 개선되었지만 여전히 데이터 중심 설계 방식에 속한다고 봐도 무방하다
    - 어떤 문제점이 있는지 살펴본다.
    
    ### 캡슐화 위반
      - 수정된 객체들을 자신의 데이터를 스스로 처리한다
      - 다만 이상한 부분들이 몇가지 있다
      - 기간 조건을 판단하는 isDiscountTable(week, time) 메서드를 보면 DiscountCondition의 속성으로 포함된 요일 정보와 시간 정보를 파라미터로 받는 것으로 객체 내부에 DayOfWeek, LocalTime 타입의 데이터가 포함된걸 노출하고 있다
      - 두번째 isDiscountTable(sequence) 역시 int 타입의 데이터를 객체가 가지고 있음을 노출한다
      - getType 메서드 역시 데이터를 노출해버린다.
      - 만약 DiscountCondition 의 속성 정보를 변경해야 하는 상황이 생긴다면? -> 메서드 파라미터에 대한 변경이 불가피 하고 다른 객체에도 변경이 전파가 된다.
      - 이러한 파급효과는 캡슐화가 부족하다는 명백한 증거다.
      - Movie 역시 calculateAmountDiscountedFee, calculatePercentDiscountedFee, calculateNonDiscountedFee 메서드 들은 할인 정책 자체를 노출 시키고 있기 때문에 역시 캡슐화에 대한 위반이다.
    - 진정한 캡슐화란 단순히 속성을 외부에 감추는 것만이 아니라 변경될수 있는 모든것들을 외부에 감추는 것이라고 한다. 그것이 속성의 타입이건, 할인 정책의 종류건 내부 구현의 변경으로 인해 외부의 객체가 영향을 받는다면 캡슐화를 위반한 것이다.
    
    ### 높은 결합도
      - 캡슐화 위반으로 인해 DiscountCondition 의 내부 구현이 외부로 노출이 됐기 때문에 Movie, DiscountCondition 사이의 결합도는 높을 수 밖에 없다.
      - Movie, DiscountCondition 코드에서 어떤 문제가 발생하는가?
        - DiscountCondition 의 기간 할인 조건의 명칭이 PERIOD에서 다른 이름으로 바뀐다면 Movie를 수정해야 한다.
        - DiscountCondition 의 종류가 추가 되거나 삭제 된다면 Movie안의 if ~ else 구문을 수정해야 한다.
        - 각 DiscountCondition 의 만족 여부를 판단하는데 필요한 정보가 변경된다면 movie의 isDiscountTable 메서드로 전달될 파라미터를 변경해야 한다.
        
    ### 낮은 응집도
      - 결과적으로 할인 조건의 종류를 변경하기 위해서는 DiscountCondition, Movie 그리고 Movie를 사용하는 Screening을 함께 수정해야 한다
      - 하나의 변경을 수용하기 위해 코드의 여러 곳을 동시에 변경한다는 것은 설계의 응집도가 낮다는 것이다.
      - 응집도가 낮은 것은 캡슐화를 위반했기 때문이다.
    - refactor가 legacy 보다 개선된건 맞지만 데이터 중심의 설계가 가지는 문제점으로 인해 몸살을 앓고 있다는 점에는 변함이 없다.
    
  ## 4-6 데이터 중심 설계의 문제점
  
    > 두번쨰 변경이 유연하지 못한 이유는 캡슐화를 위반했기 때문이다. 캡슐화를 위반한 설계를 구성하는 요소들이 높은 응집도와 낮은 결합도를 가질 확률은 극히 낮다.
    - 데이터 중심의 설계가 변경에 취약한 이유는 두 가지다.
      1) 데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다
      2) 데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 체 오퍼레이션을 결정한다.
   ### 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다.
      - 데이터 중심 설계에 익숙한 프로그래머는 일반적으로 데이터와 기능을 분리하는 절차적 프로그래밍 방식을 따른다.
      - 데이터를 먼저 결정하고 데이터를 처리하는 데 필요한 오퍼레이션을 나중에 결정하는 방식은 캡슐화 하는데 실패하고 코드는 변경에 취약해진다.
   ### 데이터 중심 설계는 객체를 고립시킨채 오퍼레이션을 정의하도록 만든다
      - 객체지향 어플리케이션을 구현한다는 것은 협력하는 객체들의 공동체를 구축한다는 것을 의미한다.
      - 따라서 협력이라는 문맥안에서 필요한 책임을 결정하고 이를 수행할 적절한 객체를 결정하는 것이 가장 중요하다
      - 올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야한다.
      - 안타깝게도 데이터중심설계에서 초점은 객체의 외부가 아니라 내부로 향한다. 실행문맥에 대한 고민없이 객체가 관리할 데이터의 세부 정보를 먼저 결정한다.
        - 객체의 구현이 이미 결정된 상황에서 다른객체와의 협력방법을 고민하기 때문에 이미 구현된 객체의 인터페이스를 억지로 끼워맞출 수 밖에 없다.
        - 이게 두번째 설계가 실패한 이유이다.
# 오브젝트 5장 책임 할당
  > 이번 파트는 GRASP 패턴이라는 것을 이해해 책임 할당의 어려움을 해결하기 위한 내용들을 공부한다.
  ## 5-1 책임 주도 설계로
  - 데이터 중심의 설계에서 책임 중심의 설계로 전환하기 위해선 다음의 두가지 원칙을 따라야 한다.  
    ### 데이터보다 행동을 먼저 결정하라
      - 앞에서 부터 계속 해왔던 이야기 지만 객체는 내부보다 외부에 제공하는 행동이 더 중요하다
      - 데이터 중심 설계는 이 객체가 어떤 데이터를 가지고 있는지 고민한후 행동을 고민하는데 책임 중심 설계는 책임(행동)에 대해 고민하고 그 책임에 필요한 데이터를 고민한다.
      - 객체지향 설계에서 가장 중요한건 적절한 객체에 적절한 책임을 할당하는 것이다. 그럼 어떻게 잘 할당하나? 그건 협력이라는 문맥에서 실마리를 찾을 수 있다고 한다.
    ### 협력이라는 문맥안에서 책임을 결정하라
      > 객체에게 할당된 책임의 품질은 협력에 적합한 정도로 결정된다. 객체에게 할당된 책임이 협력에 어울리지 않는 다면 그 책임은 부적절한 것이다. 객체의 입장에서는 책임이 조금 어색해 보일지 몰라도 협력에 적합하다면 그 책임은 좋은것이다.
      - 책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야 한다
      - 협력을 시작하는 주체는 메시지의 전송자이기 때문에 협력에 적합한 책임이란 메세지 수신자가 아니라 메세지 전송자에게 적합한 책임을 의미하고 다시 말해 클라이언트의 의도에 적합한 책임을 할당해야 한다는 의미이다
      - 협력에 적합한 책임을 수확하기 위해서는 메세지를 결정한 후에 객체를 선택해야 한다. 메세지가 존재하기 때문에 그 메세지를 처리할 객체가 필요한것이다.
      - 객체가 메세지를 선택하는 것이 아니라 메세지가 객체를 선택하게 해야 한다(일상에서 비유하자면 해야하는 일이 생겨서 사람을 채용하는 것과 비슷한 맥락인것 같다.)
    ### 책임 주도 설계
      - 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
      - 시스템 책임을 더 작은 책임으로 분할 한다.
      - 분할된 책임을 수행하라 수 있는 적절한 객쳋 또는 역할을 찾아 책임을 할당한다.
      - 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또느느 역할을 찾는다.
      - 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

  ## 5-2 책임 할당을 위한 GRASP 패턴
  > 객체지향이 태어나 성숙해가는 동안 많은 사람들이 다양한 책침 할당 기법을 고안했다. 그중 대중적으로 가정 널리 알려진 것은 크레이그 라만이 패턴 형식으로 제안한 GRASP패턴이다.
  - GRASP패턴은 객체에게 책임을 할당할때 지침으로 삼을수 있는 원칙들의 집할을 패턴 형식으로 정리한 것이다.
  - 설계를 시작하기 전에 도메인에 대한 대략적인 모습을 그려보는 것이 좋다.
  - 설계를 시작하는 단계에서는 개념들의 의미와 관계가 정확하거나 완벽할 필요가 없다. 이 단계에서는 책임을 할당받을 객체들의 종류와 관계에 대한 유용한 정보를 제공할 수 있다면 충분하다.
    ### 정보 전문가에게 책임을 할당하라
      - 책임 주도 설계 방식의 첫 단계는 어플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각하는 것이다.
      - 이 책임을 어플리케이션에 대해 전송된 메시지로 간주하고 이 메시지를 책임질 첫 번쨰 객체를 선택하는 것으로 설계를 시작한다.
      - 만약 사용자에게 제공할 기능이 영화 예매면 어플은 영화를 예매할 책임이 있다고 할 수 있다. 이제 이 책임을 수행하는데 필요한 메시지를 결정해야 한다.
      - 메시지는 메시지를 받는 객체가 아닌 보내는 객체의 의도를 반영해서 결정해야 한다.
      - 위의 내용을 토대로 처음 생각해봐야할 질문은 "메시지를 전송할 객체는 무엇을 원하는가?" 이고 메시지는 "예매하라" 라는 메시지가 적합해 보인다.
      - 이제 메시지를 받을 객체를 정해야 한다.객체는 자신의 상태와 행동을 스스로 처리하는 자율적 존재 이다
      - 객체에게 책임을 할당하는 첫번쨰 원칙은 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것이다. GRASP에서는 이를 "INFORMATION EXPERT 정보전문가 패턴" 이라고 한다
        - 여기서 이야기 하는 정보는 데이터와는 다르다는 사실을 알아야 한다.
        - 책임을 수행하는 객체가 정보를 '알고' 있다고 해서 그 정보를 '저장'하고 있을 필요는 없다. 객체는 해당정보를 제공할 수 있는 다른 객체를 알고 있거나 필요한 정보를 계산해서 제공할 수도 있다.
        - INFORMATION EXPERT 에 따르면 예매에 필요한 정보를 가장 많이 알고 있는 객체에 예매하라 메시지를 처리 할 책임을 할당해야 하고 아마 상영이라는 객체가 가장 적절하다고 판단할 것이다.(영화에 대한 정보, 상영시간, 상영순번 같은 내용 포함)
        - 다만 설계시에 데이터가 포함되어야 하는게 아니라 개략적인것이다. 아예 데이터가 포함되어 있지 않는 것은 아닌것 같다. 기본적인 데이터를 염두해 둔체로 도메인 설계를 진행하는듯하다.
        - 아무튼 이제 '상영'이 해야할 작업의 흐름을 생각해봐야 한다. 설계기 때문에 대략적으로 '상영'이 책임을 수행하기 위해 필요한 작업을 구상해보고 스스로 처리할 수 없는 작업이 무엇일지를 가릴 정도면 된다.
        - 스스로 처리할수 없는 작업이 있다면 외부에 도움을 요청해야 하고 이것이 새로운 메시지가 되어 또 다른 책임을 할당해야 한다.
      - 이런식으로 INFORMATION EXPERT 패턴은 객체에게 책임을 할당할 때 가장 기본이 되는 책임 할당원칙이다. 해당 패턴을 따르는 것 만으로도 자율설이 높은 객체들로 구성된 협력 공동체를 구축할 가능성이 높아진다.
      ### 높은 응집도와 낮은 결합도
        - 동일한 기능을 구현할 수 있는 무수히 많은 설계방식이 존재하고 설계를 하다보면 몇가지 설계중 한 가지를 선택해야 하는 경우가 빈번하게 발생한다.
        - 이 경우 올바른 책임 할당을 위해 INFORMATION EXPERT 패턴 이외의 다른 책임 할당 패턴들을 함께 고려할 필요가 있다.
        - 높은 응집도와 낮은 결합도는 객체에 책임을 할당할 때 항상 고려해야 하는 기본 원리이다.
        - 책임을 할당할 수 있는 다양한 대안들이 존재한다면 응집도와 결합도의 측면에서 더 나은 대안을 선택하는 것이 좋다. 다시말해 여러 설계중 높은 응집도와 낮은 결합도를 제일 잘 구현할 수 있는 설계를 선택하면 뙨다.
        - GRASP 에선 이를 LOW COUPLING(낮은 결합도) 패턴과 HIGH COHESION(높은 응집도) 패턴이라 부른다.
          > LOW COUPLING(낮은 결합도)는 예를 들면 예제의 DiscountCondition이 Movie와 협력하는 것이 좋은가 Screening과 협력하는 것이 좋은가?
          - 실마리는 결합도에 있다. Movie와 DiscountCondition은 이미 결합되어 있기에 결합도를 추가할 필요가 없는 반면 Screening은 DiscountCondition와 새로운 결합을 만들어줘야 하기때문에 Movie와의 협력이 좋은 설계가 된다.

          > HIGH COHESION(높은 응집도)는 만약 DiscountCondition이 Screening과 협력 한다면?
          - Screening은 요금 계산의 책임을 일부 가지게 되고 예매요금 구현이 변경사항이 생기게 되면 Screening도 함께 변경되야 한다. 그런데 Screening의 책임은 예매를 '생성' 하는것이다. 객체의 책임이 더 생겨버리고 서로 다른이유로 변경이 될 수 있게 되버린다.
          - 반면 Movie의 주된 책임은 영화 요금을 계산하는 것이다. 따라서 영화 요금을 계산 하는데 필요한 할인 조건을 판단하기 위해 Movie가 DiscountCondition와 협력하는 것은 문제가 되지 않고 응집도에도 아무런 해를 끼치지 않는다

        - LOW COUPLING(낮은 결합도)와 HIGH COHESION(높은 응집도) 패턴은 설계를 진행하며 책임과 협렵의 품질을 검토하는데 사용할 수 있는 중요한 평가 기준이다.
        - 둘의 관점에서 전체적인 설계 품질을 검토하면 단순하면서 재사용가능한, 유연한 설계를 얻을 수 있다.

    ### 창조자에게 객체 생성 책임을 할당하라
      > 영화 예매 협력의 최종 결과물은 Reservation 인스턴스를 생성하는 것이고 협력에 참여한 어떠한 객체에는 Reservation생성 책임이 할당되야한다.
      - CREATOR(창조자) 패턴은 이같은 경우에 사용할 수 있는 책임 할당 패턴으로 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공한다.
        - 객체 A를 생성할 때 어떤 객체에게 객체 생성 책임을 할당해야 하는가?
        - 객체B가 A 객체를 포함하거나 참조한다
        - 객체B가 A 객체를 기록한다.
        - 객체B가 A 객체를 긴밀하게 사용한다.
        - 객체B가 A 객체를 초기화하는데 필요한 데이터를 가지고 있다.
      - CREATOR(창조자) 패턴의 의도는 ㅓㅇ던 방식으로든 생성되는 객체와 견결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것이다.
      - 생성될 객체에 대해 잘 알고 있어야 하거나 그 객체를 사용해야 하는 객체는 어떤 방식으로든 생성될 객체와 연결될 것이다.
      - 이미 결합되 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않는다.
      - 예제에선 Reservation에 대해 잘알고 있는 객체는 Screening이다.
      - Screening은 영화 예매에 필요한 영화, 상영시간, 상영순번 등의 정보에 대한 전문가 이며 예매 요금을 계산하는 Movie도 알고 있기 때문에 CREATOR로 적합하다.

  ## 5-3 구현을 통한 검증
  > 해당 내용은 책을 보는 편이 정리에 빠르다.. 물론 예제로 작성했지만 자세한 설명은 정리보다 책이 최고다
  - 초반 내용을 정리하면 쭉 설명해왔던 책임 중심 설계를 직접 보여준다. 큰 협력을 정하고 첫 매세지를 정하고, 알맞는 객체를 정하고, 해당 객체에 책임(메서드)를 할당하고, 이후에 책임에 필요한 내용을들 구상하고, 다시 메세지를 만들고... 이과정을 보여준다.
  - 이제 구현된 내용중 DiscountCondition을 개선할 필요가 있다.
  - DiscountCondition은 서로다른 3가지 이율호 변경될 수 있다.
    1) 새로운 할인 조건 추가 : isSatisfiedBy 메서드의 if ~ else 구문애 새로운 할인조건에 대한 내용을 추가해야 하고 또 새로운 조건이 새로운 데이터를 요구하면 DiscountCondition에 추가해야 한다.
    2) 순번 조건을 판단하는 로직이 변경되는 경우 : isSatisfiedBySequence 메서드의 내부 구현을 변경해야 한다. 물론 로직이 변경되 새로운 데이터가 필요한 경우 추가되거나 sequence에 대한 변경도 필요하다
    3) 기간 조건을 판단하는 로직이 변경되는 경우 : isSatisfiedByPeriod 메서드의 내부 구현을 변경해야 한다. 물론 로직이 변경되 새로운 데이터가 필요한 경우 추가되거나 시간데이터들에 대한 변경도 필요하다.
  - DiscountCondition은 하나 이상의 변경 이유를 가지기 때문에 응집도가 낮다고 할수 있고 응집도가 낮다는 건 연관성이 없는 기능이나 데이터가 하나의 클래스 안에 뭉쳐져있다는 것을 의미한다.
  - 따라서 낮은 응집도가 초래하는 문제를 해결하기 위해선 "변경의 이유에 따라 클래스를 분리해야 한다."
  - 일반적으로 설계를 개선하는 작업은 변경의 이유가 하나 이상인 클래스를 찾는것으로부터 시작하는 것도 좋다.
  - 변경의 이유가 하나 이상인 클래스는 위험징후를 또렷하게 드러내는 몇가지 패턴이 존재한다
    1) 첫번째는 "인스턴스 변수가 초기화되는 시점"을 살펴보는 것이다.
      - 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화 한다.
      - 반면 응집도가 낮은 클래스는 객체의 속성중 일부만 초기화하고 일부는 초기화되지 않은 상태로 생성된다.
      - DiscountCondition 클래스를 보면 순번조건을 표현하는 경우 sequence는 초기화 되지만 시간관련 변수는 초기화되지 않고 반대역시 시간관련 변수는 초기화 되지많 sequence는 초기화 되지않는다.
      - 따라서 함께 초기화되는 속성을 기준으로 코드를 분리해야 한다.
    2) 두번쨰는 "메서드들이 인스턴스 변수를 사용하는 방식" 을 살펴 보는 것이다.
      - 모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다고 볼수 있다
      - 반면 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮다고 볼 수 있다.
      - DiscountCondition의 isSatisfiedBySequence 메서드는 sequence는 사용하지만 다른 시간관련 변수는 사용하지 않고 반대로 isSatisfiedByPeriod 메서드는 시간관련 변수는 사용하지만 sequence는 사용하지 않는다.
      - 이 경우 클래스의 응집도를 높이기 위해서는 "속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다".
  - 추가 내용이 있지만 책을 보면서 하는게 훨씬 편하고 이해도 쉽다. 아니면 나의 정리하는 능력이 부족....ㅜ 책 154p~165p

  ## 5-4 리팩토링
  - 처음부터 책임중심설계는 어려울수 있다.
  - 데이터 중심으로 설계해 구현후 리팩토링하는 과정을 통해 책임중심설계와 유사하게 만들수 있다.

# 6장 메세지와 인터페이스
> 객체지향 어플리케이션의 가장 중요한 재료는 클래스가 아니라 객체들이 주고받는 메시지다. 클래스 사이의 정적인 관계에서 메시지 사이의 동적인 흐름으로 초점을 전환하는 것은 미숙함을 벗어나 숙련된 객체지향 설계자로 성장하기 위한 첫걸음이다ㅣ
- 어플리케이션은 클래스로 구성되지만 메시지를 통해 정의 된다는 것을 기억해야 한다
- 다만 훌륭한 퍼블릭 인터페이스를 얻기 위해선 책임주도 설계방법을 따르는것 만으로 부족하고 유연하고 재사용 가능한 퍼블릭 인터페이스를 만드는데 도움이되는 설계 원칙과 기법을 익히고 적용해야 한다
  ## 6-1 협력과 메세지
  > 설계 원칙과 기법을 배우기 전 간단하게 용어에 대한 교통정리 부터 하고 진행한다
   ### 클라이언트-서버 모델
     - 메세지는 객체 사이의 협력을 가능하게 하는 매개체다. 객체가 다른객체에 접근할 수 있는 유일한 방법은 메시지를 전송하는 것 뿐이다.
     - 두 객체 사이의 협력 관계를 설명하기 위해서 사용하는 전통적 메타포는 클-서버 모델이다. 대학 강의 시간에도 여러번 본적이 있다.
     - 객체세계에선 객체는 협력에 참여하는 동안 클과 서버의 역할을 동시에 수행하는 것이 일반적이다. 메시지를 받아서 처리하기도 하고, 또 메세지를 보내 필요한 내용을 받기도 한다.
   ### 메시지와 메시지전송
     - 메시지 : 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.
     - 메시지 전송 : 한 객체가 다른객체에게 도움을 요청하는 것
     - 메시지는 '오퍼레이션명'과 '인자'로 구성되며 메시지 전송은 여기에 '메시지 수신자'를 추가한 것이다. 따라서 메세지 전송은 메시지 수신자, 오퍼레이션명, 인자 의 조합이다
     - condition.isSatisfiedBy(screening) -> condition : 수신자, isSatisfiedBy : 오퍼레이션명, screening: 인자
   ### 메시지와 메서드
     > 메시지를 수신했을때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인지(클래스가 무엇인지)에 달려있다. -> condition.isSatisfiedBy 는 어떤 클래스의 isSatisfiedBy매서드가 실행될지 모른다.
     - 메서드 : 이렇게 메시지를 수신했을때 실제로 실행되는 함수 또는 프로시저를 메서드 라고 부른다.
   ### 퍼블릭 인터페이스와 오퍼레이션
     - 퍼블릭 인터페이스 : 객체가 외부와 의사소통하기 위해 외부에 공개하는 메시지의 집할을 퍼블릭 인터페이스 라고 부른다.
     - 오퍼레이션: 퍼블릭 인터페이스에 포함된 메시지. 주로 인터페이스에 정의된 메서드들을 오퍼레이션이라고 한다
     - 시그니처 : 오퍼레이션의 이름과 파라미터 목록을 합쳐 시그니처라고 부른다.
     - 오페레이션은 실행코드 없이 시그니처만 정의한것이고 메서드는 이 시그니처에 구현을 더한것이다.
  ## 6-2 인터페이스와 설계 품질
  > 비록 책임 주도 설계 방법이 훌륭한 인터페이스를 얻을 수 있는 지침을 제공한다고 하더라도 훌륭한 인터페이스가 가지는 공통적인 특징을 아는 것은 안목을 넓히고 올바른 설계에 도달할 수 있는 지름길을 제공할수 있다
  - 지금은 퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법에 관해 살펴본다
   ### 디미터 법칙
   ```
   public class ReservationAgency {
       public Reservation reserve(Screening screening, Customer customer, int audienceCount) {
           Movie movie = screening.getMovie();

           boolean discountTable = false;
           for (DiscountCondition discountCondition : movie.getDiscountConditions()) {
               if (discountCondition.getType() == DiscountConditionType.PERIOD) {
                   discountTable = screening.getWhenScreened().getDayOfWeek().equals(discountCondition.getDayOfWeek()) &&
                           discountCondition.getStartTime().compareTo(screening.getWhenScreened().toLocalTime()) <= 0 &&
                           discountCondition.getEndTime().compareTo(screening.getWhenScreened().toLocalTime()) >= 0;
               } else {
                   discountTable = discountCondition.getSequence() == screening.getSequence();
               }

               if (discountTable) {
                   break;
               }
           }
   ```
     - 위코드의 문제는 ReservationAgency와 Screening 사이의 결합도가 너무 높기 때문에 Screening의 내부 구현을 변경할 때마다 ReservationAgency도 함께 변경된다는 것이다.
     - 만약 Screening이 Movie를 포함하지 않게 된다면? Movie가 DiscountCondition 포함하지 않게 변경된다면? 이런 저런 변경에도 흔들리는것이 ReservationAgency 이다.
     - 이렇게 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이 바로 디미터 법칙이다.
     - 디미터 법칙을 간단히 요약하면 객체내부의 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.
     - 자세한 설명은 184p를 참고하고(어렵다...) 간단하게 아래의 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍 해야 한다라고 이해해도 무방하다
       - this 객체
       - 메서드의 매개변수
       - this의 속성
       - this의 속성인 컬렉션의 요소
       - 메서드 내에서 생성된 지역 객체
     - 해서 위의 코드를 디미터 법칙을 적용해 줄이면
     ```
     public class ReservationAgency {
       public Reservation reserve(Screening screening, Customer customer, int audienceCount) {
         Money fee = screening.calculateFee(audienceCount);
         return new Reservation(customer, screening, fee, audienceCount)
       }
     ```
     - 위와 같이 매개변수였던 screening에 계산 자체를 맡겨 ReservationAgency는 calculateFee라는 메세지만 던졌다.
     > 디미터 법칙은 캡슐화른 다른 관점에서 표현한 것이다. 디미터 법칙이 가치있는 이유는 클래스를 캡슐화 하기 위해 따라야 하는 구체적인 지침을 제공하기 때문이다. 캡슐화 원칙이 클래스 내부의 구현을 감춰야 한다는 사실을 강조한다면 디미터 법칙은 협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한한다.
     ```
     screening.getMovie().getDiscountConditions();
     ```
     - 위의 코드는 전형적으로 디미터 법칙을 위배하는 코드이다. 흔히 이와 같은 코드를 기차 충동이라고 부른다. 기차 충돌은 클래스의 내부 구현이 외부로 노출됐을때 나타나는 전형적인 형태이다.
     - 하지만 무비판적으로 디미터 법칙을 수용하면 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질수도 있다.

    ### 묻지말고 시켜라
     > 묻지말고 시켜라 원칙또한 디미터 법칙 처럼 객체의 상태에 관해 묻지말고 원하는 것을 시켜야 한다는 사실을 강조하고 이러한 스타일의 메시지 작성을 장려하는 원칙을 가리키는 용어이다.
     - 즉 위의 내용처럼 뭔가 얻어오는 게 아닌 원하는 동작을 시켜서 원하는 값을 받아야 한다는 것이다.
     - 묻.시 원칙을 따르면 객체의 정보를 이용하는 행동을 객체의 외부가 아니니 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스에 두게 된다. 또한 자연스럽게 정보 전문가에게 책임을 할당하게 되고 높은 응집도를 가진 클래스를 가질 확률을 높혀준다
     - 객체 내부의 상태를 묻는 오퍼레이션을 인터페이스에 포함시키고 있다면 더 나은 방법은 없는지 고려해봐야 하고, 내부의 상태를 이용해 어던 결정을 내리는 로직이 객체 외부에 존재한다면 객채의 책임이 외부로 누수 된것이다.
     - 즉 상태를 묻는 오퍼레이션을 -> 행동을 요청하는 오퍼레이션 으로 대체함으로서 인터페이스를 향상시킨다.

    ### 의도를 드러내는 인터페이스
      - 메서드 이름 명명에는 두가지 방법이 있다
      - 첫번쨰는 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름을 짓는것이다
        - 다만 해당 방법은 이름이 다른 내용이어도 같은 내용을 수행하지만 이 내부구현을 정확히 이해하지 못하고 이름만봤을때 같은 동작을 한다는것은 알기 어렵다
        - ex : isSatisfiedByPeriod, isSatisfiedBySequence 는 모두 할인조건을 판단하는 동일한 잡업을 수행하지만 메서드네임만을 보고 동일한 동작을 한다고 판단하기 어렵다
        - 그리고 더 큰문제는 메서드 네이밍으로 객체가 어떤 구현을 가지고 있는지 노출할 수 있기 때문에 네이밍으로 캡슐화를 해칠수 있다. 실제로 속성 이름이 변경되거나 교체 된다면 메서드 네임도 바뀌어야 한다.
      - 두번쨰는 어떻게가 아니라 무엇을 하는지를 드러내는 것이다.
        - 무엇을 하는지를 드러내는 네이밍을 짓기 위해서는 객체가 협력안에서 수행해야하는 책임에 대해 고민하게 되기 때문에 협력하는 클라이언트의 의도에 부합하도록 네이밍을 하게 된다

   ## 6-3 원칙의 함정
   > 디미터 법칙과 묻지말고 시켜라 스타일은 훌륭한 설계원칙 이지만 절대적인 법칙은 아니다. 소프트웨어 설계에 법칙이란 존재하지 않는다 법첵에는 예외가 없지만 원칙에는 예외가 넘친다. 다만 모든건 트레이드오프의 산물이다.
   - 결과적으로 원칙이 현재 상황에 부적합하다고 판단된다면 원칙을 과감히 무시해라.
   - **원칙을 아는것보다 더 중요한것은 원칙이 언제 유영하고 언제 유용하지 않은지를 판단할수 있는 능력을 기르는 것이다.**
    ### 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다.
    - 한가지 예로 IntStream을 든다
    ```
    IntStream.of(1, 15, 20 ,3 ,9).filter(x -> x> 10).distinct().count();
    ```
    - 위의 IntStream 은 디미터 법칙을 위해한다고 생각할 수도 있겠지만 위의 내용들은 결국 IntStream인스턴스를 또 다른 IntStream을 인스턴스로 변환한다.
    - 따라서 위 코드는 디미터 법칙을 위반하지 않는다 디미터 법칙은 결합도와 관련된 것이고 이 결합도가 문제가 되는 것은(높아지는 것은) 객체의 내부 구조가 외부로 노출되는 경우로 한정된다.
    - 또 위 내용은 객체의 내부에 대한 어떤 내용도 묻지 않고 그저 객체를 다른 객체로 변환하는 작업을 수행한다. 따라서 묻지말고 시켜라 원칙또한 위반하지 않는다
     ### 결합도와 응집도의 충돌
     - 묻지말고 시켜라와 디미터 법칙을 준수하는것이 항상 긍정적인 결과로만 이어지는것은 아니다.
     - 모든 상황에서 맹목적으로 위임 메서드를 추가하면 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게 된다.
     - 결과적으로 객체는 상관없는 책임들을 한꺼번에 떠안게 되기 때문에 결과적으로 응집도가 낮아진다.
     - 예로 예제의 DisCountCondition 내용을 보면 알 수 있다
     ```
     dayOfWeek.equals(screening.getWhenScreened().getDayOfWeek()) &&
                     startTime.compareTo(screening.getWhenScreened().toLocalTime()) <= 0 &&
                     endTime.compareTo(screening.getWhenScreened().toLocalTime()) >= 0;
     ```
     - 위의 내용은 DisCountCondition 의 코드임에도 Screening의 내용을 많이 사용하고 있어 캡슐화를 위반한 것 처럼 보인다. 그렇다면 Screening으로 내용을 옮겨야 할까?
     - 하지만 Screening 으로 옮기게 되면 Screening이 기간에 따른 할인 조건을 판단하는 책임을 떠안게 된다. Screening은 영화을 예매하는 책임이 있는 객체이다.
     - 결국 Screening이 할인 조건은 팔단하게 되면 객체의 응집도가 낮아진다. 반면 DisCountCondition의 입장에선 할인 조건을 판단하는 책임이 본질이다.
     - 게다가 Screening은 DisCountCondition의 속성이 변경되게 되면 역시 영향을 받게 되버린다.
     - 예제와는 별개의 내용이지만 또한 가끔씩은 직접 데이터를 묻는 행위 외에는 다른 방법이 없는 경우도 있다
     - 결국 요첨은 **소프트웨어 세계에서 법칙이란 존재하지 않는다. 중요한건 원칙이 적절한 상황과 부적절한 상황을 판단할 수 있는 안목을 길러야 한다. 라는 것이다. 설계는 트레이드 오프의 산물이다.**
     - **소프트웨어 세계에서 몇 안되는 법칙중 하나는 "경우에 따라 다르다" 이다.**

    ## 6-4 명령-쿼리 분리 원칙
    > 가끔씩은 필요에 따라 물어야 한다는 사실에 납득했다면 명령-쿼리 분리 원칙을 알아두면 도움이 될것이다
    - 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈을 '루틴'이라고 부른다.
    - 루틴은 다시 '프로시저'와 '함수' 로 구분할 수 있따.
    - 프로시저는 정해진 절차에 따라 내부의 상태를 변경하는 루틴의 한 종류다.
    - 함수는 어떤 절차에 따라 필요한 값을 계산해서 반환하는 루틴의 한 종류다.
    - 명령과 쿼리는 객체의 인터페이스 측면에서 함수를 부르는 또 다른 이름이다.
    - 명령 = 프로시저, 쿼리 = 함수 라고 할 수 있다.
    - 명령-쿼리 분리 원칙의 요지는 오퍼레이션은 부수 효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리중 하나여야 한다는 것이다.
    - 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안된다. 따라서 명령과 쿼리를 분리하기 위해서는 다음의 두가지 규칙을 준후해야 한다.
      - 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
      - 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.
    - 205p~210p 까지 예시가 있다. 요약하자면 복잡한 메서드 내에 명령과 쿼리가 혼재 되어 있어서 버그발생 원인을 파악하는데 오래걸렸다. 메서드를 명령과 쿼리 형식으로 나눠서 사용하자.

   - 디미터 법칙을 준수하고 묻지 말고 시켜라 스타일을 따르면서도 의도를 드러내는 인터페이스를 설계하는 쉬운 방법은 메시지를 먼저 선택하고 그 후에 메시지를 처리할 객체를 선택하는 것이다.
   - 결국 원점으로 돌아가 책임 주도 설계 원칙을 따르는 것이 유연하고 재사용 가능한 객체지향 설계를 이끌어낸다.

# 7장 객채 분해
> 사람에게는 장기기억과 단기 기억이 있고 장기기억은 오래 기억되고 많은 내용을 기억할 수 있지만 한번에 내용에 접근하기가 쉽지 않다. 단기기억은 접근은 쉽지만 용량이 적고 금방 휘발될 가능성이 높다
- 이에 따라 사람들은 한꺼번에 다뤄야하는 정보의 수를 줄이기 위해 본질적인 정보만 남기고 불필요한 정보는 걸러내면 문제를 단순화 할 수 있을 것이라고 생각했고 이 과정을 '추상화' 라고 부른다
- 가장 일반적 추상화 방법은 한번에 다뤄야 하는 문제의 크기를 줄이는것이다. 이렇게 해결가능한 작은 문제로 나누는 과정을 '분해'라고 한다
- 인류역사에 복잡성이 있는 곳엔 추상화와 분해가 존재했고 그 분야는 소프트웨어 개발도 포함된다
 ## 7-1 프로시저 추상화와 데이터 추상화
   - 프로그래밍 언어의 발전은 좀더 효과 적인 추상화를 이용해 복잡성을 극복하려는 개발자들의 노력에서 시작됐다.
   - 이런 과정들 속에서 프로그래밍 패러다임들이 탄생하게 되는데 모두 적절한 추상화의 윤곽을 따라 시스템을 어떤식으로 나눌 것인지를 결정하는 원칙과 방법의 집합이다.
   - 현대적인 프로그래밍 언어를 특징 짓는 중요한 두가지 추상화 매커니즘은 '프로시저 추상화'와 '데이터 추상화'다.
     - 프로시저 추상화는 소프트웨어가 무엇을 해야 하는지를 추상화한다
     - 테이터 추상화는 소프트웨어가 무엇을 알아야 하는지를 추상화한다.
   - 시스템을 분해하는 방법을 결정하려면 먼저 프로시저 추상화를 중심으로 할것인지 데이터 추상화를 중심으로 할 것인지 결정해야 한다.
     - 프로시저를 중심으로 분해한다면 기능분해의 길로 들어서는것이다
     - 데이터를 중심으로 분해한다면 두가지중 하나를 선택해야 한다
       - 데이터를 중심으로 '타입'을 추상화 하는 것. '추상 데이터 타입'이라고 한다
       - 데이터를 중심으로 '프로시저'를 추상화 하는것이다. '객체지향' 이라고 한다.

- 7장은 프로시저 추상화와 데이터 추상화를 비교하고 마지막엔 객체지향에 대한 내용을 보여주며, 각 패러다임은 어떻게 구현되고 어떤 문제들이 있는지, 지금의 객체지향과 어떤 차이가 있는지?, 왜 객체지향이라는 페러다임이 대세인지 를 세세하게 코드를 통해 설명한다
- 결국 본질은 '협력'과 '책임'을 중심으로한 설계가 재사용성과 유연함을 갖출수 있다는 내용이다.