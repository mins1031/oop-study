# 객체지향 프로그래밍 입문
## 객체
  ### 절차지향 vs 객체지향
    - 절차지향 : 절자지향은 하나의 데이터를 여러 프로시저(함수,메서드)가 공유하는 방식이라고 할 수 있다.
      - 이러한 방식은 처음엔 쉽지만 프로그램의 규모가 커지게 된다면 데이터를 공유하는 방식은 구조를 점점 복작하게 만들고 -> 수정을 어렵게 만든다
    - 객체지향 : 객체지향은 데이터와 프로시저를 객체라는 단위로 묶고 특정 객체가 갖고 있는 데이터는 해당 객체의 프로시저로만 접근할 수 있게 구현한다.
      - 객체란: 객체의 핵심은 '기능제공'이다. **객체는 제공하는 기능으로 정의한다.(내부적으로 가진 데이터=필드 로 정의하지 않는다.)**
        - ex: 회원 객체
          - 암호 변경 기능
          - 차단 여부 확인 하기 기능
        - ex: 소리 제어기
          - 소리크기 증가 기능
          - 소리크기 감소 기능
  - 다만 아래와 같은 경우를 객체라고 할 수 있을까?
  ```
  class member {
      private String name;
      private String id;

      public String getName() {
        return this.name;
      }

      public void setName(String name) {
        this.name = name
      }

      public String getId() {
        return this.id;
      }

      public void setId(String id) {
        this.id = id
      }
  }
  ```
  - 의견은 갈리겠지만 객체라기 보단 DTO에 가까운 그냥 데이터 구조체라고 할 수 있다
  - 위의 구조에서 세터가 빠지고 기능적인 메서드가 들어가면 비로소 객체라고 할 수 있다고 생각한다
## 캡슐화
  > 캡슐화만 잘해도 좋은 코드를 만들 가능성이 높아진다고 한다. 그럼 어떻게 높혀주나?
  - 데이터 + 관련기능 묶기
  - 객체가 기능을 어떻게 구현했는지는 외부에 감추는 것이다.(구현에 사용된 데이터의 상세 내용을 외부에 감춤)
  - 정보 은닉 의미 포함
  - 캡슐화가 잘되어 있으면 외부에 영향없이(거의..?) 객체내부 구현 변경이 가능하다
  ### 캡슐화 하지 않으면
    - 요구사항이 변화가 데이터 구조/사용에 변화를 발생시킨다.
    - 만약 account라는 객체에 대한 요구사항이 바뀌어 객체내용을 수정해야 하는 상황에선 해당 변경사항부분을 사용하는 모든 내용을 변경해줘야 할 수도 있기 때문에 대량 코드 수정이 연쇄적으로 발생한다.
  ### 캡슐화를 하게 되면
    - 기능을 제공하고 구현 상세를 감춰 준다.
      - 만약 정회원을 인증하는 코드가 서비스 로직에서 산재되어있는 경우(정회원의 권한과 서비스 기간에 따라 인증여부가 결정된다.). 인증의 방식이 회원의 데이터를 이용하는 것이기 때문에 회원 객체 안으로 해당 인증로직을 옮겨 놓고 서비스 로직에선 해당 객체의 인증로직만 가져다 사용하면 연쇄 로직 수정을 최소화 할 수 있다.
      - 캡슐화를 시도하게 되면 ** 기능에 대한 이해를 높힐 수 있다.**
  ### 캡슐화를 위한 규칙
    1) Tell, Don't Ask
      - 데이터를 달라고 하지 말고 해달라고 하기
      ```
      if(acc.getMembership() == REGULAR) {
         ...정회원 기능
      }
      ->
      if(acc.hasRegularPermission) {
               ...정회원 기능
      }
      ```
      - 위의 내용은 직접 acc의 membership이 regular인지 확인하고 있고 밑의 내용은 acc에서 확인 된 결과를 받는다.
      - 결과자체를 받을 때 캡슐화가 더 잘 치켜질 가능성이 커진다.
    2) Demeter's Law
      - 메서드에서 생성한 객체의 메서드만 호출
      - 파라미터로 받은 객체의 메서드만 호출
      - 필드로 참조하는 객체의 메서드만 호출
      ```
      -> 의 오른쪽이 개선된 코드이다.
      acc.getExpDate().isAfter(now) -> acc.isExpired()

      Date date = acc.getExpDate();  date.isAfter(now) -> acc.isValid(now)
      ```
      - 즉 해당 메서드에서 생성한, 파라미터로 받은, 필드에서 참조하는 객체의 데이터를 가져와서 가공하지 말고 메서드를 통해 가공 된걸 가져오라는 의미이다.
      - 캡슐화의 관점에선 데이터를 들고 있는 쪽에서 가공하는 로직이 있는게 기본적으로는 더 좋다고 생각되는 것 같다. 나역시 동일하다.

## 디형성
  - '여러 모습을 같는 것'을 다형성이라고 한다
  - 객체지향에서는 한 객체가 여러 타입을 갖는 것을 의미한다.
    - 즉 한객체가 여러 타입의 기능을 제공
    - 타입 상속으로 다형성 구(하위 타입은 상위 타입도 됨)
## 추상화
  - 데이터나 프로세스등을 의미가 비슷한 개념이나 의미있는 표현으로 정의하는 과정
  - 두 가지 방식의 추상화
    - 특정한 성질, 공통성질(일반화)
  - 간단한 예
    - DB의 USER 테이블 : 아이디, 이름 , 이메일
    - Money 클래스 : 통화, 금액