# 객체지향 프로그래밍 입문
## 객체
  ### 절차지향 vs 객체지향
    - 절차지향 : 절자지향은 하나의 데이터를 여러 프로시저(함수,메서드)가 공유하는 방식이라고 할 수 있다.
      - 이러한 방식은 처음엔 쉽지만 프로그램의 규모가 커지게 된다면 데이터를 공유하는 방식은 구조를 점점 복작하게 만들고 -> 수정을 어렵게 만든다
    - 객체지향 : 객체지향은 데이터와 프로시저를 객체라는 단위로 묶고 특정 객체가 갖고 있는 데이터는 해당 객체의 프로시저로만 접근할 수 있게 구현한다.
      - 객체란: 객체의 핵심은 '기능제공'이다. **객체는 제공하는 기능으로 정의한다.(내부적으로 가진 데이터=필드 로 정의하지 않는다.)**
        - ex: 회원 객체
          - 암호 변경 기능
          - 차단 여부 확인 하기 기능
        - ex: 소리 제어기
          - 소리크기 증가 기능
          - 소리크기 감소 기능
  - 다만 아래와 같은 경우를 객체라고 할 수 있을까?
  ```
  class member {
      private String name;
      private String id;

      public String getName() {
        return this.name;
      }

      public void setName(String name) {
        this.name = name
      }

      public String getId() {
        return this.id;
      }

      public void setId(String id) {
        this.id = id
      }
  }
  ```
  - 의견은 갈리겠지만 객체라기 보단 DTO에 가까운 그냥 데이터 구조체라고 할 수 있다
  - 위의 구조에서 세터가 빠지고 기능적인 메서드가 들어가면 비로소 객체라고 할 수 있다고 생각한다
## 캡슐화
  > 캡슐화만 잘해도 좋은 코드를 만들 가능성이 높아진다고 한다. 그럼 어떻게 높혀주나?
  - 데이터 + 관련기능 묶기
  - 객체가 기능을 어떻게 구현했는지는 외부에 감추는 것이다.(구현에 사용된 데이터의 상세 내용을 외부에 감춤)
  - 정보 은닉 의미 포함
  - 캡슐화가 잘되어 있으면 외부에 영향없이(거의..?) 객체내부 구현 변경이 가능하다

  ### 캡슐화 하지 않으면
    - 요구사항이 변화가 데이터 구조/사용에 변화를 발생시킨다.
    - 만약 account라는 객체에 대한 요구사항이 바뀌어 객체내용을 수정해야 하는 상황에선 해당 변경사항부분을 사용하는 모든 내용을 변경해줘야 할 수도 있기 때문에 대량 코드 수정이 연쇄적으로 발생한다.

  ### 캡슐화를 하게 되면
    - 기능을 제공하고 구현 상세를 감춰 준다.
      - 만약 정회원을 인증하는 코드가 서비스 로직에서 산재되어있는 경우(정회원의 권한과 서비스 기간에 따라 인증여부가 결정된다.). 인증의 방식이 회원의 데이터를 이용하는 것이기 때문에 회원 객체 안으로 해당 인증로직을 옮겨 놓고 서비스 로직에선 해당 객체의 인증로직만 가져다 사용하면 연쇄 로직 수정을 최소화 할 수 있다.
      - 캡슐화를 시도하게 되면 ** 기능에 대한 이해를 높힐 수 있다.**

  ### 캡슐화를 위한 규칙
    1) Tell, Don't Ask
      - 데이터를 달라고 하지 말고 해달라고 하기
      ```
      if(acc.getMembership() == REGULAR) {
         ...정회원 기능
      }
      ->
      if(acc.hasRegularPermission) {
               ...정회원 기능
      }
      ```
      - 위의 내용은 직접 acc의 membership이 regular인지 확인하고 있고 밑의 내용은 acc에서 확인 된 결과를 받는다.
      - 결과자체를 받을 때 캡슐화가 더 잘 치켜질 가능성이 커진다.
    2) Demeter's Law
      - 메서드에서 생성한 객체의 메서드만 호출
      - 파라미터로 받은 객체의 메서드만 호출
      - 필드로 참조하는 객체의 메서드만 호출
      ```
      -> 의 오른쪽이 개선된 코드이다.
      acc.getExpDate().isAfter(now) -> acc.isExpired()

      Date date = acc.getExpDate();  date.isAfter(now) -> acc.isValid(now)
      ```
      - 즉 해당 메서드에서 생성한, 파라미터로 받은, 필드에서 참조하는 객체의 데이터를 가져와서 가공하지 말고 메서드를 통해 가공 된걸 가져오라는 의미이다.
      - 캡슐화의 관점에선 데이터를 들고 있는 쪽에서 가공하는 로직이 있는게 기본적으로는 더 좋다고 생각되는 것 같다. 나역시 동일하다.

## 다형성
  - '여러 모습을 같는 것'을 다형성이라고 한다
  - 객체지향에서는 한 객체가 여러 타입을 갖는 것을 의미한다.
    - 즉 한객체가 여러 타입의 기능을 제공
    - 타입 상속으로 다형성 구(하위 타입은 상위 타입도 됨)

## 추상화
  - 데이터나 프로세스등을 의미가 비슷한 개념이나 의미있는 표현으로 정의하는 과정
  - 두 가지 방식의 추상화
    - 특정한 성질, 공통성질(일반화)
  - 간단한 예
    - DB의 USER 테이블 : 아이디, 이름 , 이메일
    - Money 클래스 : 통화, 금액

  ### 타입 추상화
    - 여러 구현 클래스를 대표하는 상위 타입을 도출하는 것
      - 흔히 인터페이스 타입으로 추상화한다
      - 추상화 타입과 구현은 타입 상속(implement)으로 연결된다.
      - EmailNotifier, SMSNotifier, KakaoNotifier 콘크리트 클래스들은 각각 알림을 보내는 구현 로직 클래스 들이고 이것들은 Notifier라는 인터페이스(상위타입)로 추상화가 가능하다

    - 추상 타입 사용
      - 추상 타입을 이용한 프로그래밍
      ```
      Notifier notifier = getNotifier(...);
      notifier.notify(someNoti)
      ```
      - 추상 타입은 구현을 감춘다. -> 기능의 구현이 아닌 의도자체를 더 잘 드러내 준다.
      - 추상타입 사용에 따른 이점 : 유연함. -> ExampleAbstractionBenefit 확인해보면 결국 주문취소라는 메서드의 역할과 상관 없이 알림 방식이 바뀌어 가면서 역할과 다른 내용 때문에 역할 메서드가 복잡하고 커질수가 있다.
      - 추상화 결과: 사용대상 변경이 유연하다. -> Notifier를 인터페이스로 추상화 했기 때문에 간단한 코드만으로 여러 알림객체를 유연하게 적용 가능함.

    - 추상화는 의존대상이 변경하는 시점에 적용 해야 한다
      - 추상화를 하면 -> 추상 타입 증가 -> 복잡도 증가
        - 결국 아직 존재하지 않는 기능에 대한 이른 추상화는 잘못된 추상화를 할 가능성도 있고, 코드 복잡도를 증가시킬 여지가 있기 때문에 주의해야 한다.
        - 실제 변경이나 확장이 발생할 때 추상화를 시도하는 것이 바람직하다.
    - 추상화를 잘 하려면 구현한 이유가 무엇 때문인지 생각해봐야 한다.

## 상속보단 조립
  ### 상속을 통한 기능 재사용 발생할 수 있는 단점
    1) 상위 클래스 변경에 어려움을 겪게 된다. -> 상위 클래스를 변경하게 되면 하위 클래스에 영향을 줄 수 있다. 또한 어떤 하위 클래스가 추가 될지 모르기 때문에 상위 클래스 변경에 더 어려움을 겪게 된다. 캡슐화도 약해지게 된다.
    2) 클래스가 증가하게 된다 -> 하나의 기능에 대해 상속을 진행하면 진행할 수록 여러 케이스에 대한 애매한 상황들이 발생할 수 있다.
    3) 상속을 오용할 수 있다. -> 하위클래스에서 오버라이드한 메서드를 사용해야 하는데 싱위클래스의 메서드를 사용하는 경우도 발생할 수 있다.
  - 해결책은 상속보단 조립을 사용하는 것이다.
  - 조립
    - 여러 객체를 묶어서 더 복잡한 기능을 제공
    - 보통 필드로 다른 객체를 참조하는 방식으로 조립 또는 객체를 필요시점에 생성/구하는 방식으로 구현.
